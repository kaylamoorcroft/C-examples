-- Sat, March 16, Afternoon --
1. DEFINE "STUDENT" STRUCT TO STORE STUDENT DATA
- Review structs and figure out if need to return struct, ptr or both
- Since bonus section specifies we need to create array of pointers to struct,
will make able to return both
- Going to use typedef and return both

2. STRUCT INITIALIZATION AND PRINTING
- Going to make constructor using pointer to struct for call by reference as in
slides. Don't want to have to assign values manually in main()
- Can use shortcut for initialization by using {} but think it's more readable
using the general assignment & ->
- I don't think I need a method to compare the structs. It just talks about
finding highest GPA and sorting by GPA later in assignment.
- However, I do need something that will print out the info for the struct
- When scroll down in slides Darcy says we can declare the structs in multiple
different ways so that we can access the struct in different ways. Eg. he showed
constructor return T, TP and void (modifying TP that passed in). I'm confused
now what the best approach is, so I'm going to watch the recording back and here
what he says about this. For now, I'll just leave the constructor that take in
StudentTP as arg.
- Loop for input & different loop for print
- Added clearLine() method like in previous assignment so I don't have the issue
with the \n char when taking input
- All the names in the array are the last entry from user. I think this is 
because it is pointer & not actual value that is being used to assign name 
attribute. Maybe I should use strcpy() in constructor. gonna look at man page
to remember syntax
- Think this not work because I don't have any memory assigned to the string - 
it's just a pointer. So I can't copy data there. So I either need to make it so 
that struct name is char array instead of pointer, then can copy over string.
But that limits string length which is bad for long names. Or I can find a way
to pass in value of name when assign it in constructor instead of reference
- Going to try casting it as const char* -> Still does the same thing.
- Just gonna do char array thing with fixed cap instead because only foolproof 
way can think of easily right now. Don't want to overcomplicate things. could
use malloc and then do strcpy as well but we don't need to put it on the heap
and struggle with managing own memory just for this purpose
- Still have issue where only read in string until new line because that's how
%s works in scanf() -> maybe have to use getchar() till EOL but will see if
there's a specific string related method for it in slides -> going to use fgets
because can limit # chars read in & can stop when reach EOL - just specify 
stream as stdin
- I forgot that it stores the \n char -> makes printing weird because I don't
want a line between name and rest of info. Could just use gets instead but then
can't limit number of chars read and it might overflow... Gonna test what 
happens if enter more than max chars (50) that array store and will see if can
do error checking to prevent crash 
- The compiler doesn't want me to do this because "gets is deprecated". So I'll
just find a way to remove \n char at end or just not print it. Can look for \n
in constructor after copy string over and then just replace it with \0

-- Sat, March 16, Evening --
3. HIGHEST GPA FINDER
- It says to find student with highest GPA so will return student and not GPA
(ie. return the whole struct)
- Will loop & keep track of "best student"
- Can't find size of array so need to pass in number of students
- Or maybe can actually just loop until student is null - will try both methods and then see.
- What about if multiple students have the same highest GPA? Should return all
names? -> maybe can find highest GPA value and then compare all GPAs to that 
value and print out students inside method. Then don't have to worry about 
return values anyway. 
- Can't error check for "null". Tried checking if name of first student is empty 
to determine empty array but maybe they just put a blank name -> will make 
method that sees if struct's values are all their initial values (ie. null / 0)
to determine if the struct is "null" / "empty"
- Tried to make all methods take studentTP instead of studentT so that it's call
by reference and doesn't make a copy of the struct but for the highest gpa 
finder I have to pass in an array of students. Don't know how to put array of
studentTP as parameter when working with an array of studentT - because just 
putting & in front doesn't work. keep getting same warning:
incompatible pointer types passing 'StudentT (*)[2]' to parameter of type 'StudentTP *' (aka 'StudentT **') [-Wincompatible-pointer-types]
    highestGpa(&students);
- I wonder if it would work if I tried to cast it to the correct type -> it got
rid of the warning but it still doesn't work and crashes with "zsh: segmentation 
fault a.out" -> I think the accessing of the students doesn't work because it
crashes when it tries to check if it's null. 
- Is it really so bad if I try to do reference by value for this one time??
- Oh... I said to continue the loop while "isNullStudentT(&students[i]) != 0"
but 0 is "false" for null -> meaning that it's not null!! so it's supposed to be
continuing the loop while the return value is == 0!

-- Sat, March 16, Night --
4. SORTING ELEMENTS BY GPA
- For sorting, can take in pointer to original array & then just swap students
in spots. Make temp var for this.
- Oof, I can't get around not passing in the pointer this time. Maybe I should
make the array in main() of StudentTP instead of StudentT so that I can do call
by reference especially for this method where I have to change the original
array
- Changing the constructor to return TP as well instead of just modifying TP 
because I think I need to allocate the memory for these pointers myself
- I got everything else to work but for some reason I get another segmentation
fault when trying to pass in StudentTP students[] again 
- Something is working now... I think I have to pass in only TP and can't pass
in array of TP. But still want to increment through it so can probably only pass
in first element. But need to see if can still increment. Currently only reads
first student
- Think I should scrap the "null" method idea because I keep getting
segmentation faults which apparently means that I'm accessing memory that I 
shouldn't (ie. memory in the array that I didn't allocate) - going to try 
passing size as a parameter and see how that goes. Okay, this fixes the problem

-- Sun, March 17, Afternoon --
- Didn't test my code yet but I know it is not going to work because I'm only
swapping adjacent students
- Idea: Compare first student to rest of students. Then second student to rest,
etc. Basically just a nested loop where the inner loop start index is set to
current outer loop index. 
ie. for (int i = 0; i < size - 1; i++) {
	for (int j = i + 1; j < size; j++) {/*code*/}
}
- Alright, this seems to work. I'm going to move on to the bonus section now

-- Sun, March 17, Evening --
BONUS SECTION
- Going to make csv file first for testing - going to get names from random name
generator because I'm bad at making up names. Also going to randomly generate
IDs between 100000-999999. Gpa as well. Using excel for the random number 
generation and creating the csv in general
- Make function for reading file that creates array of 99 struct pointers 
(since file size <100 lines max # structs is 99). Then allocate space for this
pointer. But only allocate space for each struct once it reads the values if
there is something in the line in the file.
- Can use strtok to separate by comma. Have to find a way to convert the int
and float to the correct type though -> can use strtod -> then just cast as int
or float. Oh, there is one for floats according to the man pages - strtof. And 
from the slides, I could use strtol but then I have to specify it's in base 10
and I still need to convert it to an int. So I don't really see the difference.
Maybe just that the double takes up more space. 
- Use example from slides of reading in csv file line by line
- It reads in the whole file but it keeps reading after the last line then 
causes a segmentation fault. I think I should check whether the line is blank 
to make sure. -> for some reason it is the fgets in the loop itself which is 
causing the segmentation fault because it doesn't even go inside the loop. ->
it was an issue with the file itself - for some reason when I used excel to 
create a csv file then exported it, it added 2 commas in the last line which
is what caused the error.

-- Sun, March 17, Night --
- Now do constructor inside loop. Can change while loop to for loop to have 
index, but keep stopping condition same as while loop
- Okay, it reads it in and I can make it print the elements like the previous
array. But I wouldn't know the size, so I'm not sure how to pass in the size for
the other functions... maybe I have to find a way without knowing the size or
maybe I need to make a method for finding the size...
- Just saw if pointer was null while going in loop then keep track of index. 
This seems to work but I'm going to test it with the initial code as well. It
only works if the memory was allocated with malloc or calloc otherwise there is
a segmentation fault since we are trying to read memory we aren't allowed to.
But in this case, I knew the size of the array I wanted so I just used [] 
instead of a pointer and then allocating it with malloc. But if I want the 
methods to be generic, and not want methods where I have to pass in the size and
others where I don't have to, then I should probably allocate it using malloc
- My highest gpa finder wasn't working for the students from the file. I saw 
that I declared my local variable "highest" as an int. Changing it to a float 
and seeing if this works. Because it saved "highest" as 4 when the highest is 
actually 4.28 -> okay, fixed.

CHECKING OVER ASSIGNMENT 
- I'm not sure about whether I was supposed to use a StudentTP array or a 
StudentT array in main() for creating the arrays of students. I'm confused about
the implications of both.
- Also, I should probably deallocate all the memory used at some point. I'm just
unsure how to go about this. Because I allocated memory for the array. Then for
each element. I'm also confused about the process behind this. I thought you 
would only need to allocate memory for the array. Maybe I can make a deallocate
function that takes in the address of the array and deallocates it, but also 
deallocates all of the memory used for each item
- Maybe I should email Darcy to just clear up this whole concept.

-- Mon, March 18, Afternoon --
- Going to make the deallocation function now - go through each element in array
and deallocate (free(p) + p = NULL). Then deallocate whole array's pointer as 
well.
- Reading over the instructions again, I'm confused whether the print function
is supposed to take in an array of students or a single student.

-- Tue, March 19, Afternoon --
- Darcy said that generally if know size, should make array of StudentT but if
don't know size, like with file, make array of StudentTP. But don't want to 
rework all methods when do bonus section so can make the array of 5 students 
with StudentTP 
- Tested deallocation function - doesn't through any errors and I tried to find
size of array - works. 
- Array pointer isn't null - realised I didn't do deallocation correctly. Again
made parameter *p instead of **p. -> fixed it, but now need to remember how to
access pointers of array elements to free individual elements -> had to put 
brackets the right way - was doing *students[i] but when I changed it to 
(*students)[i] it worked. Now each studentTP is null and whole array is null
- Going to make makefile now and then upload. Not going to split code into a
module again even though it would probably be a good idea because of file length
